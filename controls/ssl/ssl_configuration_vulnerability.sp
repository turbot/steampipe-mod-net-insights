variable "cbc_cipher_suites" {
  type        = list(string)
  description = "A list of CBC mode cipher suites."
  default     = [
    "TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA",
    "TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA",
    "TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA",
    "TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA",
    "TLS_RSA_WITH_AES_128_CBC_SHA",
    "TLS_RSA_WITH_AES_256_CBC_SHA",
    "TLS_ECDHE_RSA_WITH_3DES_EDE_CBC_SHA",
    "TLS_RSA_WITH_3DES_EDE_CBC_SHA",
    "TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256",
    "TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256",
    "TLS_RSA_WITH_AES_128_CBC_SHA256",
    "TLS_RSA_EXPORT_WITH_RC2_CBC_40_MD5",
    "TLS_RSA_EXPORT_WITH_DES40_CBC_SHA",
    "TLS_DH_RSA_WITH_3DES_EDE_CBC_SHA",
    "TLS_DH_DSS_WITH_CAMELLIA_256_CBC_SHA",
    "TLS_DHE_DSS_EXPORT_WITH_DES40_CBC_SHA",
    "TLS_RSA_WITH_IDEA_CBC_SHA",
    "TLS_DH_anon_EXPORT_WITH_DES40_CBC_SHA",
    "TLS_DHE_DSS_WITH_DES_CBC_SHA",
    "TLS_DH_anon_WITH_DES_CBC_SHA",
    "TLS_DHE_RSA_WITH_3DES_EDE_CBC_SHA",
    "TLS_DH_DSS_EXPORT_WITH_DES40_CBC_SHA",
    "TLS_DH_anon_WITH_3DES_EDE_CBC_SHA",
    "TLS_DH_DSS_WITH_DES_CBC_SHA",
    "TLS_DHE_RSA_WITH_DES_CBC_SHA",
    "TLS_DH_DSS_WITH_3DES_EDE_CBC_SHA",
    "TLS_KRB5_WITH_DES_CBC_SHA",
    "TLS_DH_RSA_EXPORT_WITH_DES40_CBC_SHA",
    "TLS_RSA_WITH_DES_CBC_SHA",
    "TLS_KRB5_WITH_3DES_EDE_CBC_SHA",
    "TLS_DHE_DSS_WITH_3DES_EDE_CBC_SHA",
    "TLS_DH_RSA_WITH_DES_CBC_SHA",
    "TLS_DH_anon_WITH_AES_256_CBC_SHA",
    "TLS_DHE_RSA_EXPORT_WITH_DES40_CBC_SHA",
    "TLS_KRB5_WITH_IDEA_CBC_SHA",
    "TLS_KRB5_WITH_DES_CBC_MD5",
    "TLS_DHE_RSA_WITH_AES_256_CBC_SHA256",
    "TLS_DHE_DSS_WITH_AES_256_CBC_SHA256",
    "TLS_DH_anon_WITH_AES_128_CBC_SHA256",
    "TLS_RSA_WITH_AES_256_CBC_SHA256",
    "TLS_KRB5_WITH_3DES_EDE_CBC_MD5",
    "TLS_DH_anon_WITH_AES_256_CBC_SHA256",
    "TLS_DH_DSS_WITH_AES_128_CBC_SHA256",
    "TLS_DHE_RSA_WITH_AES_128_CBC_SHA256",
    "TLS_DH_RSA_WITH_AES_128_CBC_SHA256",
    "TLS_DH_DSS_WITH_AES_256_CBC_SHA256",
    "TLS_DH_RSA_WITH_AES_256_CBC_SHA256",
    "TLS_DH_RSA_WITH_CAMELLIA_128_CBC_SHA",
    "TLS_DH_DSS_WITH_AES_128_CBC_SHA",
    "TLS_DHE_DSS_WITH_CAMELLIA_128_CBC_SHA",
    "TLS_KRB5_WITH_IDEA_CBC_MD5",
    "TLS_DHE_DSS_WITH_AES_128_CBC_SHA256",
    "TLS_KRB5_EXPORT_WITH_DES_CBC_40_SHA",
    "TLS_RSA_WITH_CAMELLIA_256_CBC_SHA",
    "TLS_DH_RSA_WITH_AES_128_CBC_SHA",
    "TLS_KRB5_EXPORT_WITH_RC2_CBC_40_SHA",
    "TLS_RSA_WITH_CAMELLIA_128_CBC_SHA",
    "TLS_DHE_DSS_WITH_AES_128_CBC_SHA",
    "TLS_DHE_RSA_WITH_AES_128_CBC_SHA",
    "TLS_KRB5_EXPORT_WITH_DES_CBC_40_MD5",
    "TLS_KRB5_EXPORT_WITH_RC2_CBC_40_MD5",
    "TLS_DH_anon_WITH_AES_128_CBC_SHA",
    "TLS_DHE_RSA_WITH_CAMELLIA_128_CBC_SHA",
    "TLS_DH_anon_WITH_CAMELLIA_128_CBC_SHA",
    "TLS_DH_DSS_WITH_CAMELLIA_128_CBC_SHA",
    "TLS_DH_RSA_WITH_CAMELLIA_256_CBC_SHA",
    "TLS_DHE_DSS_WITH_AES_256_CBC_SHA",
    "TLS_DH_RSA_WITH_AES_256_CBC_SHA",
    "TLS_DHE_RSA_WITH_AES_256_CBC_SHA",
    "TLS_RSA_WITH_SEED_CBC_SHA",
    "TLS_RSA_PSK_WITH_AES_256_CBC_SHA",
    "TLS_DH_DSS_WITH_AES_256_CBC_SHA",
    "TLS_DH_DSS_WITH_SEED_CBC_SHA",
    "TLS_DHE_DSS_WITH_CAMELLIA_256_CBC_SHA",
    "TLS_DHE_RSA_WITH_SEED_CBC_SHA",
    "TLS_DH_anon_WITH_SEED_CBC_SHA",
    "TLS_DH_RSA_WITH_SEED_CBC_SHA",
    "TLS_DHE_RSA_WITH_CAMELLIA_256_CBC_SHA",
    "TLS_DH_anon_WITH_CAMELLIA_256_CBC_SHA",
    "TLS_PSK_WITH_AES_128_CBC_SHA256",
    "TLS_PSK_WITH_AES_256_CBC_SHA384",
    "TLS_PSK_WITH_3DES_EDE_CBC_SHA",
    "TLS_PSK_WITH_AES_128_CBC_SHA",
    "TLS_PSK_WITH_AES_256_CBC_SHA",
    "TLS_DHE_PSK_WITH_AES_128_CBC_SHA256",
    "TLS_DHE_DSS_WITH_SEED_CBC_SHA",
    "TLS_DHE_PSK_WITH_3DES_EDE_CBC_SHA",
    "TLS_DHE_PSK_WITH_AES_256_CBC_SHA384",
    "TLS_DHE_PSK_WITH_AES_128_CBC_SHA",
    "TLS_ECDH_anon_WITH_3DES_EDE_CBC_SHA",
    "TLS_DHE_PSK_WITH_AES_256_CBC_SHA",
    "TLS_ECDH_ECDSA_WITH_ARIA_256_CBC_SHA384",
    "TLS_RSA_PSK_WITH_AES_128_CBC_SHA256",
    "TLS_RSA_PSK_WITH_3DES_EDE_CBC_SHA",
    "TLS_RSA_PSK_WITH_AES_256_CBC_SHA384",
    "TLS_RSA_PSK_WITH_AES_128_CBC_SHA",
    "TLS_ECDH_anon_WITH_AES_128_CBC_SHA",
    "TLS_RSA_WITH_CAMELLIA_128_CBC_SHA256",
    "TLS_ECDH_anon_WITH_AES_256_CBC_SHA",
    "TLS_DH_DSS_WITH_CAMELLIA_128_CBC_SHA256",
    "TLS_DH_RSA_WITH_CAMELLIA_128_CBC_SHA256",
    "TLS_SRP_SHA_WITH_3DES_EDE_CBC_SHA",
    "TLS_DHE_DSS_WITH_CAMELLIA_128_CBC_SHA256",
    "TLS_SRP_SHA_RSA_WITH_3DES_EDE_CBC_SHA",
    "TLS_DHE_RSA_WITH_CAMELLIA_128_CBC_SHA256",
    "TLS_DH_anon_WITH_CAMELLIA_128_CBC_SHA256",
    "TLS_SRP_SHA_DSS_WITH_3DES_EDE_CBC_SHA",
    "TLS_RSA_WITH_CAMELLIA_256_CBC_SHA256",
    "TLS_ECDH_RSA_WITH_3DES_EDE_CBC_SHA",
    "TLS_DH_DSS_WITH_CAMELLIA_256_CBC_SHA256",
    "TLS_SRP_SHA_WITH_AES_128_CBC_SHA",
    "TLS_ECDH_RSA_WITH_AES_128_CBC_SHA",
    "TLS_DH_RSA_WITH_CAMELLIA_256_CBC_SHA256",
    "TLS_SRP_SHA_RSA_WITH_AES_128_CBC_SHA",
    "TLS_DHE_DSS_WITH_CAMELLIA_256_CBC_SHA256",
    "TLS_ECDH_RSA_WITH_AES_256_CBC_SHA",
    "TLS_DHE_RSA_WITH_CAMELLIA_256_CBC_SHA256",
    "TLS_SRP_SHA_DSS_WITH_AES_128_CBC_SHA",
    "TLS_DH_anon_WITH_CAMELLIA_256_CBC_SHA256",
    "TLS_SRP_SHA_WITH_AES_256_CBC_SHA",
    "TLS_ECDH_ECDSA_WITH_3DES_EDE_CBC_SHA",
    "TLS_SRP_SHA_RSA_WITH_AES_256_CBC_SHA",
    "TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA",
    "TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA",
    "TLS_ECDHE_PSK_WITH_AES_256_CBC_SHA",
    "TLS_ECDH_ECDSA_WITH_CAMELLIA_128_CBC_SHA256",
    "TLS_SRP_SHA_DSS_WITH_AES_256_CBC_SHA",
    "TLS_ECDHE_ECDSA_WITH_3DES_EDE_CBC_SHA",
    "TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA384",
    "TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA256",
    "TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA384",
    "TLS_ECDHE_PSK_WITH_AES_128_CBC_SHA256",
    "TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA384",
    "TLS_ECDHE_PSK_WITH_AES_256_CBC_SHA384",
    "TLS_ECDHE_RSA_WITH_ARIA_128_CBC_SHA256",
    "TLS_ECDH_RSA_WITH_AES_128_CBC_SHA256",
    "TLS_ECDH_RSA_WITH_AES_256_CBC_SHA384",
    "TLS_ECDH_ECDSA_WITH_CAMELLIA_256_CBC_SHA384",
    "TLS_ECDHE_RSA_WITH_CAMELLIA_128_CBC_SHA256",
    "TLS_ECDHE_RSA_WITH_CAMELLIA_256_CBC_SHA384",
    "TLS_ECDH_RSA_WITH_CAMELLIA_128_CBC_SHA256",
    "TLS_RSA_WITH_ARIA_128_CBC_SHA256",
    "TLS_ECDH_RSA_WITH_CAMELLIA_256_CBC_SHA384",
    "TLS_ECDHE_RSA_WITH_ARIA_256_CBC_SHA384",
    "TLS_RSA_WITH_ARIA_256_CBC_SHA384",
    "TLS_ECDH_RSA_WITH_ARIA_128_CBC_SHA256",
    "TLS_DH_DSS_WITH_ARIA_128_CBC_SHA256",
    "TLS_ECDH_RSA_WITH_ARIA_256_CBC_SHA384",
    "TLS_DH_DSS_WITH_ARIA_256_CBC_SHA384",
    "TLS_ECDHE_PSK_WITH_3DES_EDE_CBC_SHA",
    "TLS_DHE_PSK_WITH_CAMELLIA_256_CBC_SHA384",
    "TLS_RSA_PSK_WITH_CAMELLIA_128_CBC_SHA256",
    "TLS_ECDHE_PSK_WITH_AES_128_CBC_SHA",
    "TLS_DH_RSA_WITH_ARIA_128_CBC_SHA256",
    "TLS_RSA_PSK_WITH_CAMELLIA_256_CBC_SHA384",
    "TLS_ECDHE_PSK_WITH_CAMELLIA_128_CBC_SHA256",
    "TLS_DH_RSA_WITH_ARIA_256_CBC_SHA384",
    "TLS_DH_anon_WITH_ARIA_128_CBC_SHA256",
    "TLS_DHE_DSS_WITH_ARIA_128_CBC_SHA256",
    "TLS_ECDHE_PSK_WITH_CAMELLIA_256_CBC_SHA384",
    "TLS_DH_anon_WITH_ARIA_256_CBC_SHA384",
    "TLS_PSK_WITH_ARIA_128_CBC_SHA256",
    "TLS_DHE_DSS_WITH_ARIA_256_CBC_SHA384",
    "TLS_DHE_RSA_WITH_ARIA_128_CBC_SHA256",
    "TLS_ECDHE_ECDSA_WITH_ARIA_128_CBC_SHA256",
    "TLS_DHE_RSA_WITH_ARIA_256_CBC_SHA384",
    "TLS_PSK_WITH_ARIA_256_CBC_SHA384",
    "TLS_DHE_PSK_WITH_ARIA_128_CBC_SHA256",
    "TLS_DHE_PSK_WITH_ARIA_256_CBC_SHA384",
    "TLS_ECDHE_ECDSA_WITH_ARIA_256_CBC_SHA384",
    "TLS_PSK_WITH_CAMELLIA_128_CBC_SHA256",
    "TLS_ECDH_ECDSA_WITH_ARIA_128_CBC_SHA256",
    "TLS_PSK_WITH_CAMELLIA_256_CBC_SHA384",
    "TLS_DHE_PSK_WITH_CAMELLIA_128_CBC_SHA256",
    "TLS_RSA_PSK_WITH_ARIA_128_CBC_SHA256",
    "TLS_RSA_PSK_WITH_ARIA_256_CBC_SHA384",
    "TLS_ECDHE_PSK_WITH_ARIA_128_CBC_SHA256",
    "TLS_ECDHE_PSK_WITH_ARIA_256_CBC_SHA384",
    "TLS_ECDHE_ECDSA_WITH_CAMELLIA_128_CBC_SHA256",
    "TLS_ECDHE_ECDSA_WITH_CAMELLIA_256_CBC_SHA384"
  ]
}

variable "rc4_cipher_suites" {
  type        = list(string)
  description = "A list of RC4 cipher suites."
  default     = [
    "TLS_RSA_WITH_RC4_128_SHA",
    "TLS_ECDHE_ECDSA_WITH_RC4_128_SHA",
    "TLS_ECDHE_RSA_WITH_RC4_128_SHA",
    "TLS_RSA_WITH_RC4_128_MD5",
    "TLS_RSA_EXPORT_WITH_RC4_40_MD5",
    "TLS_KRB5_EXPORT_WITH_RC4_40_SHA",
    "TLS_DHE_PSK_WITH_RC4_128_SHA",
    "TLS_KRB5_EXPORT_WITH_RC4_40_MD5",
    "TLS_RSA_PSK_WITH_RC4_128_SHA",
    "TLS_PSK_WITH_RC4_128_SHA",
    "TLS_DH_anon_EXPORT_WITH_RC4_40_MD5",
    "TLS_DH_anon_WITH_RC4_128_MD5",
    "TLS_KRB5_WITH_RC4_128_MD5",
    "TLS_ECDH_ECDSA_WITH_RC4_128_SHA",
    "TLS_KRB5_WITH_RC4_128_SHA",
    "TLS_ECDH_anon_WITH_RC4_128_SHA",
    "TLS_ECDH_RSA_WITH_RC4_128_SHA",
    "TLS_ECDHE_PSK_WITH_RC4_128_SHA"
  ]
}

variable "rsa_cipher_suites" {
  type        = list(string)
  description = "A list of RSA encryption-based key exchange modes cipher suites."
  default     = [
    "TLS_RSA_EXPORT_WITH_DES40_CBC_SHA",
    "TLS_RSA_EXPORT_WITH_RC2_CBC_40_MD5",
    "TLS_RSA_EXPORT_WITH_RC4_40_MD5",
    "TLS_RSA_PSK_WITH_3DES_EDE_CBC_SHA",
    "TLS_RSA_PSK_WITH_AES_128_CBC_SHA",
    "TLS_RSA_PSK_WITH_AES_128_CBC_SHA256",
    "TLS_RSA_PSK_WITH_AES_128_GCM_SHA256",
    "TLS_RSA_PSK_WITH_AES_256_CBC_SHA",
    "TLS_RSA_PSK_WITH_AES_256_CBC_SHA384",
    "TLS_RSA_PSK_WITH_AES_256_GCM_SHA384",
    "TLS_RSA_PSK_WITH_ARIA_128_CBC_SHA256",
    "TLS_RSA_PSK_WITH_ARIA_128_GCM_SHA256",
    "TLS_RSA_PSK_WITH_ARIA_256_CBC_SHA384",
    "TLS_RSA_PSK_WITH_ARIA_256_GCM_SHA384",
    "TLS_RSA_PSK_WITH_CAMELLIA_128_CBC_SHA256",
    "TLS_RSA_PSK_WITH_CAMELLIA_128_GCM_SHA256",
    "TLS_RSA_PSK_WITH_CAMELLIA_256_CBC_SHA384",
    "TLS_RSA_PSK_WITH_CAMELLIA_256_GCM_SHA384",
    "TLS_RSA_PSK_WITH_CHACHA20_POLY1305_SHA256",
    "TLS_RSA_PSK_WITH_NULL_SHA",
    "TLS_RSA_PSK_WITH_NULL_SHA256",
    "TLS_RSA_PSK_WITH_NULL_SHA384",
    "TLS_RSA_PSK_WITH_RC4_128_SHA",
    "TLS_RSA_WITH_3DES_EDE_CBC_SHA",
    "TLS_RSA_WITH_AES_128_CBC_SHA",
    "TLS_RSA_WITH_AES_128_CBC_SHA256",
    "TLS_RSA_WITH_AES_128_CCM",
    "TLS_RSA_WITH_AES_128_CCM_8",
    "TLS_RSA_WITH_AES_128_GCM_SHA256",
    "TLS_RSA_WITH_AES_256_CBC_SHA",
    "TLS_RSA_WITH_AES_256_CBC_SHA256",
    "TLS_RSA_WITH_AES_256_CCM",
    "TLS_RSA_WITH_AES_256_CCM_8",
    "TLS_RSA_WITH_AES_256_GCM_SHA384",
    "TLS_RSA_WITH_ARIA_128_CBC_SHA256",
    "TLS_RSA_WITH_ARIA_128_GCM_SHA256",
    "TLS_RSA_WITH_ARIA_256_CBC_SHA384",
    "TLS_RSA_WITH_ARIA_256_GCM_SHA384",
    "TLS_RSA_WITH_CAMELLIA_128_CBC_SHA",
    "TLS_RSA_WITH_CAMELLIA_128_CBC_SHA256",
    "TLS_RSA_WITH_CAMELLIA_128_GCM_SHA256",
    "TLS_RSA_WITH_CAMELLIA_256_CBC_SHA",
    "TLS_RSA_WITH_CAMELLIA_256_CBC_SHA256",
    "TLS_RSA_WITH_CAMELLIA_256_GCM_SHA384",
    "TLS_RSA_WITH_DES_CBC_SHA",
    "TLS_RSA_WITH_IDEA_CBC_SHA",
    "TLS_RSA_WITH_NULL_MD5",
    "TLS_RSA_WITH_NULL_SHA",
    "TLS_RSA_WITH_NULL_SHA256",
    "TLS_RSA_WITH_RC4_128_MD5",
    "TLS_RSA_WITH_RC4_128_SHA",
    "TLS_RSA_WITH_SEED_CBC_SHA"
  ]
}

benchmark "ssl_configuration_vulnerabilities_check" {
  title         = "SSL/TLS Server Vulnerabilities"
  description   = "Checks if your SSL/TLS server is vulnerable to cyber attacks."
  documentation = file("./controls/docs/ssl_configuration_vulnerability_overview.md")

  children = [
    control.ssl_server_not_vulnerable_to_beast_attack,
    control.ssl_server_not_vulnerable_to_poodle_ssl_v3_attack,
    control.ssl_server_not_vulnerable_to_goldendoodle_attack,
    control.ssl_server_not_vulnerable_to_zombie_poodle_attack,
    control.ssl_server_not_vulnerable_to_sleeping_poodle_attack,
    control.ssl_server_not_vulnerable_to_openssl_0_length,
    control.ssl_server_not_vulnerable_to_robot_attack
  ]

  tags = merge(local.ssl_best_practices_common_tags, {
    type = "Benchmark"
  })
}

control "ssl_server_not_vulnerable_to_beast_attack" {
  title       = "Ensure servers are not vulnerable to BEAST attack"
  description = "BEAST stands for Browser Exploit Against SSL/TLS. A server using TLS 1.0 with block ciphers is vulnerable to BEAST. This is due to the inherent weakness in CBC that allows attackers to act as a man-in-the-middle and execute the remaining attacks. The only way to mitigate the BEAST attack is to enforce the use of RC4 suites whenever TLS 1.0 and earlier protocols are used."

  sql = <<-EOT
    select
      common_name as resource,
      case
        when (protocol = 'TLS v1.0' or protocol = 'SSL v3') and cipher_suite not in (select jsonb_array_elements_text(to_jsonb($2::text[]))) then 'alarm'
        else 'ok'
      end as status,
      case
        when (protocol = 'TLS v1.0' or protocol = 'SSL v3') and cipher_suite not in (select jsonb_array_elements_text(to_jsonb($2::text[]))) then common_name || ' is vulnerable to BEAST attack.'
        else common_name || ' is not vulnerable to BEAST attack.'
      end as reason
    from
      net_certificate
    where
      domain in (select jsonb_array_elements_text(to_jsonb($1::text[])))
    order by common_name;
  EOT

  param "dns_domain_names" {
    description = "DNS domain names."
    default     = var.dns_domain_names
  }

  param "rc4_cipher_suites" {
    description = "RC4 cipher suite list."
    default     = var.rc4_cipher_suites
  }
}

control "ssl_server_not_vulnerable_to_poodle_ssl_v3_attack" {
  title         = "Ensure servers are not vulnerable to POODLE (SSLv3) attack"
  documentation = file("./controls/docs/ssl_server_not_vulnerable_to_poodle_ssl_v3_attack.md")

  sql = <<-EOT
    with vulnerable_ciphers as (
      select
        domain,
        string_agg(cipher_suite, ', ') as cipher_suites
      from
        net_certificate
      where
        domain in (select jsonb_array_elements_text(to_jsonb($1::text[])))
        and protocol = 'SSL v3'
        and cipher_suite in (select jsonb_array_elements_text(to_jsonb($2::text[])))
      group by
        domain
    ),
    domain_list as (
      select domain from jsonb_array_elements_text(to_jsonb($1::text[])) as domain
    )
    select
      d.domain as resource,
      case
        when v.domain is null then 'ok'
        else 'alarm'
      end as status,
      case
        when v.domain is null then d.domain || ' is not vulnerable to POODLE (SSLv3) attack.'
        else d.domain || ' allows cipher suites [' || v.cipher_suites || '] which are vulnerable to POODLE (SSLv3) attack.'
      end as reason
    from
      domain_list as d
      left join vulnerable_ciphers as v on d.domain = v.domain;
  EOT

  param "dns_domain_names" {
    description = "DNS domain names."
    default     = var.dns_domain_names
  }

  param "cbc_cipher_suites" {
    description = "CBC cipher suite list."
    default     = var.cbc_cipher_suites
  }
}

control "ssl_server_not_vulnerable_to_goldendoodle_attack" {
  title         = "Ensure servers are not vulnerable to GOLDENDOODLE attack"
  documentation = file("./controls/docs/ssl_server_not_vulnerable_to_goldendoodle_attack.md")

  sql = <<-EOT
    with vulnerable_ciphers as (
      select
        domain,
        to_jsonb(string_to_array(string_agg(cipher_suite, ','), ',', '')) as ciphers
      from
        net_certificate
      where
        domain in (select jsonb_array_elements_text(to_jsonb($1::text[])))
        and protocol in ('TLS v1.2', 'TLS v1.1', 'TLS v1.0')
        and cipher_suite in ('TLS_RSA_WITH_AES_128_CBC_SHA', 'TLS_RSA_WITH_AES_256_CBC_SHA', 'TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA', 'TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA', 'TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA', 'TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA', 'TLS_RSA_WITH_3DES_EDE_CBC_SHA', 'TLS_RSA_WITH_AES_128_CBC_SHA256', 'TLS_ECDHE_RSA_WITH_3DES_EDE_CBC_SHA', 'TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256', 'TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256')
      group by
        domain
    ),
    domain_list as (
      select domain from jsonb_array_elements_text(to_jsonb($1::text[])) as domain
    )
    select
      d.domain as resource,
      case
        when v.domain is null then 'ok'
        else 'alarm'
      end as status,
      case
        when v.domain is null then d.domain || ' is not vulnerable to GOLDENDOODLE attack.'
        else d.domain || ' is vulnerable to GOLDENDOODLE attack.'
      end as reason,
      ciphers
    from
      domain_list as d
      left join vulnerable_ciphers as v on d.domain = v.domain;
  EOT

  param "dns_domain_names" {
    description = "DNS domain names."
    default     = var.dns_domain_names
  }
}

control "ssl_server_not_vulnerable_to_zombie_poodle_attack" {
  title         = "Ensure servers are not vulnerable to Zombie POODLE attack"
  documentation = file("./controls/docs/ssl_server_not_vulnerable_to_zombie_poodle_attack.md")

  sql = <<-EOT
    with vulnerable_ciphers as (
      select
        domain,
        string_agg(cipher_suite, ', ') as cipher_suites
      from
        net_certificate
      where
        domain in (select jsonb_array_elements_text(to_jsonb($1::text[])))
        and protocol in ('TLS v1.2', 'TLS v1.1', 'TLS v1.0')
        and cipher_suite in (select jsonb_array_elements_text(to_jsonb($2::text[])))
      group by
        domain
    ),
    domain_list as (
      select domain from jsonb_array_elements_text(to_jsonb($1::text[])) as domain
    )
    select
      d.domain as resource,
      case
        when v.domain is null then 'ok'
        else 'alarm'
      end as status,
      case
        when v.domain is null then d.domain || ' is not vulnerable to Zombie POODLE attack.'
        else d.domain || ' allows cipher suites [' || v.cipher_suites || '] which are vulnerable to Zombie POODLE attack.'
      end as reason
    from
      domain_list as d
      left join vulnerable_ciphers as v on d.domain = v.domain;
  EOT

  param "dns_domain_names" {
    description = "DNS domain names."
    default     = var.dns_domain_names
  }

  param "cbc_cipher_suites" {
    description = "CBC cipher suite list."
    default     = var.cbc_cipher_suites
  }
}

control "ssl_server_not_vulnerable_to_sleeping_poodle_attack" {
  title         = "Ensure servers are not vulnerable to Sleeping POODLE attack"
  documentation = file("./controls/docs/ssl_server_not_vulnerable_to_sleeping_poodle_attack.md")

  sql = <<-EOT
    with vulnerable_ciphers as (
      select
        domain,
        string_agg(cipher_suite, ', ') as cipher_suites
      from
        net_certificate
      where
        domain in (select jsonb_array_elements_text(to_jsonb($1::text[])))
        and protocol in ('TLS v1.2', 'TLS v1.1', 'TLS v1.0')
        and cipher_suite in (select jsonb_array_elements_text(to_jsonb($2::text[])))
      group by
        domain
    ),
    domain_list as (
      select domain from jsonb_array_elements_text(to_jsonb($1::text[])) as domain
    )
    select
      d.domain as resource,
      case
        when v.domain is null then 'ok'
        else 'alarm'
      end as status,
      case
        when v.domain is null then d.domain || ' is not vulnerable to Sleeping POODLE attack.'
        else d.domain || ' allows cipher suites [' || v.cipher_suites || '] which are vulnerable to Sleeping POODLE attack.'
      end as reason
    from
      domain_list as d
      left join vulnerable_ciphers as v on d.domain = v.domain;
  EOT

  param "dns_domain_names" {
    description = "DNS domain names."
    default     = var.dns_domain_names
  }

  param "cbc_cipher_suites" {
    description = "CBC cipher suite list."
    default     = var.cbc_cipher_suites
  }
}

control "ssl_server_not_vulnerable_to_openssl_0_length" {
  title         = "Ensure servers are not vulnerable to openSSL 0-length (CVE-2019-1559 vulnerability)"
  documentation = file("./controls/docs/ssl_server_not_vulnerable_to_openssl_0_length.md")

  sql = <<-EOT
    with vulnerable_ciphers as (
      select
        domain,
        string_agg(cipher_suite, ', ') as cipher_suites
      from
        net_certificate
      where
        domain in (select jsonb_array_elements_text(to_jsonb($1::text[])))
        and protocol in ('TLS v1.2', 'TLS v1.1', 'TLS v1.0')
        and cipher_suite in (select jsonb_array_elements_text(to_jsonb($2::text[])))
      group by
        domain
    ),
    domain_list as (
      select domain from jsonb_array_elements_text(to_jsonb($1::text[])) as domain
    )
    select
      d.domain as resource,
      case
        when v.domain is null then 'ok'
        else 'alarm'
      end as status,
      case
        when v.domain is null then d.domain || ' is not vulnerable to OpenSSL 0-length (CVE-2019-1559) vulnerability.'
        else d.domain || ' allows cipher suites [' || v.cipher_suites || '] which are vulnerable to OpenSSL 0-length (CVE-2019-1559) vulnerability.'
      end as reason
    from
      domain_list as d
      left join vulnerable_ciphers as v on d.domain = v.domain;
  EOT

  param "dns_domain_names" {
    description = "DNS domain names."
    default     = var.dns_domain_names
  }

  param "cbc_cipher_suites" {
    description = "CBC cipher suite list."
    default     = var.cbc_cipher_suites
  }
}

control "ssl_server_not_vulnerable_to_robot_attack" {
  title         = "Ensure servers are not vulnerable to ROBOT"
  documentation = file("./controls/docs/ssl_server_not_vulnerable_to_robot_attack.md")

  sql = <<-EOT
    with vulnerable_ciphers as (
      select
        domain,
        string_agg(cipher_suite, ', ') as cipher_suites
      from
        net_certificate
      where
        domain in (select jsonb_array_elements_text(to_jsonb($1::text[])))
        and protocol in ('TLS v1.2', 'TLS v1.1', 'TLS v1.0')
        and cipher_suite in (select jsonb_array_elements_text(to_jsonb($2::text[])))
      group by
        domain
    ),
    domain_list as (
      select domain from jsonb_array_elements_text(to_jsonb($1::text[])) as domain
    )
    select
      d.domain as resource,
      case
        when v.domain is null then 'ok'
        else 'alarm'
      end as status,
      case
        when v.domain is null then d.domain || ' is not vulnerable to ROBOT.'
        else d.domain || ' allows cipher suites [' || v.cipher_suites || '] which are vulnerable to ROBOT.'
      end as reason
    from
      domain_list as d
      left join vulnerable_ciphers as v on d.domain = v.domain;
  EOT

  param "dns_domain_names" {
    description = "DNS domain names."
    default     = var.dns_domain_names
  }

  param "rsa_cipher_suites" {
    description = "RSA key exchange based cipher suite list."
    default     = var.rsa_cipher_suites
  }
}
